<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>영상 자르기</title>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        #videoContainer { margin-bottom: 20px; }
        .controls label, .controls span, .controls input { margin-right: 5px; vertical-align: middle; }
        .time-display { font-weight: bold; }
        #videoError { color: red; margin-top: 10px; }
        button { padding: 8px 15px; cursor: pointer; }
        input[type=number] { width: 60px; }
    </style>
</head>
<body>
    <h2>영상 자르기: {{ filename }}</h2>

    <div id="videoContainer">
        <video id="video" width="600" controls>
            <source src="{{ video_url }}" type="video/mp4" />
            귀하의 브라우저는 비디오 태그를 지원하지 않습니다.
        </video>
        <div id="videoError" style="display: none;">비디오를 로드할 수 없습니다. URL을 확인하거나 다시 시도해주세요.</div>
    </div>

    <div class="controls">
        <label for="start">Start:</label>
        <input type="range" id="start" min="0" step="0.1" value="0" />
        <input type="number" id="startNumber" min="0" step="0.1" value="0" />
        <span id="startVal" class="time-display">0.0</span>s
    </div>
    <div class="controls">
        <label for="end">End:</label>
        <input type="range" id="end" min="0" step="0.1" value="0" />
        <input type="number" id="endNumber" min="0" step="0.1" value="0" />
        <span id="endVal" class="time-display">0.0</span>s
    </div>
    <br />

    <form action="{{ url_for('trim_video') }}" method="post">
        <input type="hidden" name="filename" value="{{ filename }}" />
        <input type="hidden" id="start_input" name="start_time" value="0" />
        <input type="hidden" id="end_input" name="end_time" value="0" />
        <button type="submit">이 구간으로 자르기</button>
    </form>

<script>
const video = document.getElementById("video");
const startSlider = document.getElementById("start");
const endSlider = document.getElementById("end");
const startNumber = document.getElementById("startNumber");
const endNumber = document.getElementById("endNumber");
const startValDisplay = document.getElementById("startVal");
const endValDisplay = document.getElementById("endVal");
const startHiddenInput = document.getElementById("start_input");
const endHiddenInput = document.getElementById("end_input");
const videoErrorDiv = document.getElementById("videoError");

let isPreviewing = false;
let previewInterval = null;

video.onerror = () => {
    videoErrorDiv.style.display = "block";
    startSlider.disabled = true;
    endSlider.disabled = true;
    startNumber.disabled = true;
    endNumber.disabled = true;
};

video.onloadedmetadata = () => {
    videoErrorDiv.style.display = "none";
    const duration = parseFloat(video.duration);
    if (isNaN(duration) || duration <= 0) {
        videoErrorDiv.textContent = "비디오 길이를 가져올 수 없거나 유효하지 않습니다.";
        videoErrorDiv.style.display = "block";
        startSlider.disabled = true;
        endSlider.disabled = true;
        startNumber.disabled = true;
        endNumber.disabled = true;
        return;
    }

    const durationFixed = duration.toFixed(1);

    startSlider.max = durationFixed;
    endSlider.max = durationFixed;
    startSlider.min = 0;
    endSlider.min = 0;

    startSlider.value = "0.0";
    endSlider.value = durationFixed;

    startNumber.min = 0;
    startNumber.max = durationFixed;
    endNumber.min = 0;
    endNumber.max = durationFixed;

    startNumber.value = "0.0";
    endNumber.value = durationFixed;

    startValDisplay.textContent = "0.0";
    endValDisplay.textContent = durationFixed;
    startHiddenInput.value = "0.0";
    endHiddenInput.value = durationFixed;

    startSlider.disabled = false;
    endSlider.disabled = false;
    startNumber.disabled = false;
    endNumber.disabled = false;
};

function safeParseFloat(valStr) {
    const val = parseFloat(valStr);
    return isNaN(val) ? 0 : val;
}

function updateSliderValues(slider, otherSlider, isStartSlider) {
    let val = safeParseFloat(slider.value);
    const otherVal = safeParseFloat(otherSlider.value);
    const minGap = 0.1;

    if (isStartSlider) {
        if (val >= otherVal - minGap) {
            val = Math.max(0, otherVal - minGap);
        }
    } else {
        if (val <= otherVal + minGap) {
            val = Math.min(parseFloat(video.duration), otherVal + minGap);
        }
    }

    val = Math.min(val, parseFloat(video.duration));
    val = Math.max(0, val);

    slider.value = val.toFixed(1);

    const currentFixedVal = val.toFixed(1);

    if (isStartSlider) {
        startValDisplay.textContent = currentFixedVal;
        startHiddenInput.value = currentFixedVal;
        startNumber.value = currentFixedVal;
    } else {
        endValDisplay.textContent = currentFixedVal;
        endHiddenInput.value = currentFixedVal;
        endNumber.value = currentFixedVal;
    }

    if (video.readyState >= 2) {
        startPreviewSegment();
    }
}

startSlider.oninput = () => {
    updateSliderValues(startSlider, endSlider, true);
    startNumber.value = startSlider.value;
};
endSlider.oninput = () => {
    updateSliderValues(endSlider, startSlider, false);
    endNumber.value = endSlider.value;
};

startNumber.oninput = () => {
    let val = parseFloat(startNumber.value);
    if (isNaN(val)) val = 0;
    val = Math.min(val, parseFloat(endSlider.value) - 0.1);
    val = Math.max(0, val);
    startSlider.value = val.toFixed(1);
    updateSliderValues(startSlider, endSlider, true);
};

endNumber.oninput = () => {
    let val = parseFloat(endNumber.value);
    if (isNaN(val)) val = parseFloat(video.duration);
    val = Math.max(val, parseFloat(startSlider.value) + 0.1);
    val = Math.min(val, parseFloat(video.duration));
    endSlider.value = val.toFixed(1);
    updateSliderValues(endSlider, startSlider, false);
};

function startPreviewSegment() {
    if (isPreviewing) {
        clearInterval(previewInterval);
    }
    isPreviewing = true;

    const startTime = safeParseFloat(startSlider.value);
    const endTime = safeParseFloat(endSlider.value);

    if (endTime <= startTime) {
        stopPreviewSegment();
        return;
    }

    video.currentTime = startTime;
    video.play().catch(error => {
        console.warn("Preview play failed:", error);
        stopPreviewSegment();
    });

    previewInterval = setInterval(() => {
        if (!isPreviewing) {
            clearInterval(previewInterval);
            return;
        }
        if (video.currentTime >= endTime || video.paused) {
            if (video.currentTime >= endTime && !video.paused) {
                video.currentTime = startTime;
                video.play().catch(error => console.warn("Preview loop play failed:", error));
            }
        }
    }, 150);
}

function stopPreviewSegment() {
    isPreviewing = false;
    clearInterval(previewInterval);
}

video.onclick = (event) => {
    if (event.target === video) {
        stopPreviewSegment();
    }
};

video.onpause = () => {
    if (isPreviewing) {
        stopPreviewSegment();
    }
};

startSlider.disabled = true;
endSlider.disabled = true;
startNumber.disabled = true;
endNumber.disabled = true;

</script>
</body>
</html>
